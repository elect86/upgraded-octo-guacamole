/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package upgraded.octo.guacamole

import org.w3c.dom.Node
import org.xml.sax.InputSource
import java.io.File
import java.io.StringReader
import javax.xml.parsers.DocumentBuilderFactory
import kotlin.test.Test

/**
 * A simple unit test for the 'upgraded.octo.guacamole.greeting' plugin.
 */

val projectDir = File(".").absolutePath

class UpgradedOctoGuacamolePluginTest {
    @Test
    fun `plugin registers task`() {
        // Create a test project and apply the plugin
        //        val project = ProjectBuilder.builder().build()
        //        project.plugins.apply("guacamole")

        // Verify the result
        //        assertNotNull(project.tasks.findByName("greeting"))

        parsePom(Pom.artifact, Pom.version)

        Lib.values().forEach {
            val dst = File("$projectDir/gradle/${it.filename}.toml")
            dst.writeText(it.catalog.toString())
        }
    }
}

fun parsePom(artifact: String, version: String) {

    val dbFactory = DocumentBuilderFactory.newInstance()
    val dBuilder = dbFactory.newDocumentBuilder()
    val pom = readPom(artifact, version)
    val doc = dBuilder.parse(InputSource(StringReader(pom)))

    //optional, but recommended
    //read this - http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work
    doc.documentElement.normalize()

    for (i in 0 until doc.documentElement.childNodes.length) {
        val item = doc.documentElement.childNodes.item(i)

        when (item.nodeName) {
            "parent" -> parseParent(item)
            "properties" -> parseProps(item)
            "dependencyManagement" -> {
                for (j in 0 until item.childNodes.length) {
                    val deps = item.childNodes.item(j)
                    if (deps.nodeType == Node.ELEMENT_NODE) // <dependencies/>
                        parseDeps(deps)
                }
            }
        }
    }
}

fun parseParent(node: Node) {
    println("parseParent")
    val (group, art, vers) = node.gav
    if (group == "org.scijava")
        parsePom(art, vers)
}

fun parseDeps(node: Node) {
    println("parseDeps")

    for (i in 0 until node.childNodes.length) {
        val dep = node.childNodes.item(i)

        if (dep.nodeType == Node.ELEMENT_NODE) {

            var (group, artifact, vers) = dep.gav
            vers = versions[vers.drop(2).dropLast(9)]!! // ${batch-processor.version}
            val gav = "$group:$artifact:$vers"
            if (gav !in deps) { // skip duplicates, ie <classifier>tests</classifier>
                val lib = Lib.getCurrent(group)
                val name = lib.name
                // org.scijava:scijava-cache
                // net.imagej:imagej
                // io.scif:scifio
                // org.eclipse.swt:org.eclipse.swt.cocoa.macosx
                var art = artifact.camelCase
                if (art.contains(name, ignoreCase = true)) {
                    val index = art.indexOf(name, ignoreCase = true)
                    art = art.drop(index + name.length)
                }
                art = art.decapitalize()
                deps += gav
                lib.catalog.appendLine("$art = \"$gav\"")
                println("catalog($name).alias($art).to($gav)")
            }
        }
    }
}